# 设计一个如TinyURL的生成短链接服务

> ### **Designing a URL Shortening service like TinyURL** 
>
> **Difficulty Level:Easy**

让我们设计一个像`TinyURL`这样的生成`URL`短链的服务。此服务将提供重定向到长`URL`链接的短别名。类似服务：`bit.ly`, `goo.gl`, `qlink.me`等

## 1.为什么需要URL短链？

`URL`缩短的操作用于为长`URL`创建较短的别名。我们称这些缩短的别名为"短链接"。当用户点击这些短链接时，会重定向到原始`URL`。短链接在显示、打印、发送消息或发推时可节省大量空间。此外，用户不太可能错误键入较短的`URL`。
例如，如果我们通过`TinyURL`缩短此这个链接：
`https://www.educative.io/collection/page/5668639101419520/564905025344512/5668600916475904/`
会得到：
`http://tinyurl.com/jlg8zpc`
缩短的`URL`大小几乎是实际`URL`大小的三分之一。
`URL`短链服务用于优化跨设备的链接，追踪特定链接以分析受众和活动情况，以及隐藏附属的原始`URL`。
如果你没用过`tinyurl.com`网站在此之前，请尝试创建一个新的短连接的网址，并花一些时间浏览他们的服务提供的各种选项。这对你理解这一章有很大帮助。

## 2.系统的要求和目标

> 你应该在面试开始的时候明确需求。一定要提问，找出面试官心目中的系统的边界。

我们的`URL`短链服务应满足以下要求：

#### 功能性要求:

1.给定一个`URL`，服务应该为它生成一个短且唯一的别名。这称为短链接。

2.当用户访问短链接时，服务应该将他们重定向到原始链接。

3.用户可以选择为他们的`URL`选择一个自定义的短链接。

4.链接将在标准默认时间间隔后过期。用户应该能够指定过期时间。

#### 非功能性要求：

1.系统应该是高可用的。这是必需的，因为如果我们的服务关闭，所有的`URL`重定向将开始失败。

2.`URL`重定向应该以最小的延迟实时发生。

3.缩短的链接不应该是可猜测的（不可预测的）。

#### 扩展性要求：

1.分析；例如，重定向发生了多少次？

2.我们的服务也应该可以通过**REST APIS**被其他服务访问。

## 3.容量估算和限制条件

系统读的操作很频繁。与新的`URL`短链生成相比，将有很多重定向请求。假设读写比为`100:1`。

**流量估算**：假设，我们每月将有`500 million`个新的`URL`短链，读/写比率为`100:1`，我们可以预期在同一时期有`50 billion`的重定向：

```
100*500M=>50B
```

对于我们的系统，每秒查询数（`QPS`）是多少？每秒新`URL`缩短链接服务：

```
500 millon/（30days*24hours*3600 seconds）= ~200 URL/s
```

考虑到`100:1`的读/写比，每秒的`URL`重定向将是：

```
100 * 200 URLs/s = 20K/s
```

**存储估计**：假设我们将每个`URL`缩短请求（以及相关的缩短链接）存储`5 years`。由于我们预计每月将有`5 million`个新`URL`，因此我们预计存储的对象总数将达到`30 billion`：

```
500 million * 5 years * 12 months = 30 billion
```

让我们假设每个存储的对象大约有`500 bytes`（只是一个大概的估计，我们稍后会深入研究）。我们需要`15TB`的总存储空间：

```
30 billion * 500 bytes = 15 TB
```

**带宽估计**：对于写请求，由于我们预计每秒有`200`个新`URL`，因此我们服务的总传入数据将为每秒`100KB`：

```
200 * 500 bytes = 100 KB/s
```

对于读取请求，由于我们预计每秒钟会有`~20K`个`URL`重定向，因此服务的总传出数据将为每秒`10MB`：

```
20K * 500 bytes = ~10 MB/s
```

**内存估计**：如果我们想缓存一些经常访问的热门`URL`，我们需要多少内存来存储它们？如果我们遵循二八法则，也就是说`20%`的`URL`产生`80%`的流量，我们会缓存这`20%`的热门`URL`。
由于每秒有`20K`个请求，我们每天将收到`1.7 billion`个请求：

```
20K * 3600 seconds * 24 hours = ~1.7 billion
```

要缓存20%的请求，我们需要170GB的内存。

```
0.2 * 1.7 billion * 500 bytes = ~170GB
```

这里需要注意的一点是，由于会有很多重复的请求（相同的`URL`），因此，我们的实际内存使用量将小于`170GB`。
**高容量估计**：假设每月有`500 million`个新的`URL`和`100:1`读写比例，以下是我们服务的高容量估计摘要：
新建URL	     `200/s`
URL重定向     `20K/s`
传入数据	     `100KB/s`
传出数据	     `10MB/s`
存储5年           `15TB`
缓存                 `170GB`

## 4.系统API

> 一旦我们确定了需求，定义系统API总是一个好主意。这应该明确地说明从系统中期望得到什么。

我们可以使用`SOAP`或REST APIs来暴露服务接口。以下是用于创建和删除URL的API的定义：

```java
createURL(api_dev_key, original_url, custom_alias=None, user_name=None, 
expire_date=None)
参数：
api_dev_key (string): 注册帐户的api开发人员密钥。除其他外，这将用于根据分配的配额限制用户
original_url (string): 原始URL链接
custom_alias (string): 自定义别名
user_name (string): 用于编码的用户名
expire_date (string):过期时间
Returns: (string)
返回码/错误码
deleteURL(api_dev_key, url_key)
url_key表示要检索删除的URL
```

**我们如何发现和防止服务被滥用？**恶意用户可以通过使用当前设计中的所有URL使我们瘫痪。为了防止滥用，我们可以通过用户的 `api_dev_key`来限制用户。每个 `api_dev_key.`可以在某个时间段内限制为一定数量的`URL`创建和重定向（每个开发人员密钥可以设置为不同的持续时间）。

## 5.数据库设计

> 在面试的早期阶段定义DB schema将有助于理解各个组件之间的数据流，之后将指导数据分区。

关于我们将存储的数据性质的一些观察结果：

1.    我们需要储存数十亿条记录。
2.    我们存储的每个对象都很小（小于1K）。
3.    除了存储哪个用户创建了URL之外，记录之间没有其他关系。
4.    我们的服务很重。
数据库架构：
我们需要两个表：一个用于存储关于URL映射的信息，另一个用于创建短链接的用户数据。
                                                                 URL用户
                                    span>散列：varchar（16）</span><span>用户ID:int</span>主键主键
span>原始URL:varchar（512）</span><span>名称：varchar（20）</span>创建日期：datetime</span><span>电子邮件：varchar（32）</span>过期日期：datatime</span>创建日期：datetime<br>
                                 查看器不支持]<span>上次登录：datatime</span>
我们应该使用什么样的数据库？因为我们预期存储数十亿行，而且我们不需要使用对象之间的关系——像DynamoDB、Cassandra或Riak这样的NoSQL键值存储是更好的选择。NoSQL选择也更容易扩展。有关更多详细信息，请参见SQL与NoSQL。





















