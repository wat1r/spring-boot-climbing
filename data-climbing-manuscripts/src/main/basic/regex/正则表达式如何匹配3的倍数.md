## 正则表达式如何匹配3的倍数





从前有一个问题。你选择了正则来解决，现在你有了两个问题~~~





正则引擎主要可以分为基本不同的两大类：一种是DFA（相当于之 

前说的电动机），另一种是NFA（相当于前面的汽油机）



而采用DFA的工具主要有egrep、awk、lex和flex。也有些系统采 

用了混合引擎，它们会根据任务的不同选择合适的引擎（甚至对同一表 

达式中的不同部分采用不同的引擎，以求得功能与速度之间的最佳平 

衡）

![image-20211201091733589](/Users/frankcooper/Library/Application Support/typora-user-images/image-20211201091733589.png)







00($|3|6|9|12|15)|4.2|.1.+4|55|.17 这个分更高，link:[“正则大挑战”心得](http://link.zhihu.com/?target=http%3A//jimliu.net/2014/01/04/regex-golf/)



左递归消除



![image-20211201100827350](/Users/frankcooper/Library/Application Support/typora-user-images/image-20211201100827350.png)

其实，写一个正则匹配 10 进制下 n 的倍数的思路是这样：

- 构造一个有 n 个状态的 $DFA$，状态为 $q_0,q_1...q_{n-1}$，其中起始和接受状态都是$q_0$。DFA 中 $q_k$的含义是「当前读入的数可以被 n 除余 k」(其中n是答案要求的谁的倍数，如果是3的倍数，n则等于3，k即余数，如上图中，A余0，B余1，C余2，因为是3的倍数，所有的数的余数只有0，1，2这三种)。

- 对每个![[公式]](https://www.zhihu.com/equation?tex=q_k)和$m\in{0,1,2,3,4,5,6,7,8,9}$，计算$r=(10*k+m)$   $mod$  $n$构造一条的转移边$q_k\quad\underrightarrow{m} \quad q_r$  如上图中：

  - 如$q_0\quad\underrightarrow{m} \quad q_2$也就是从A转移到C：

  ```java
  r =(10*k+m) mod n => 2 = (10*0 + m) mod 3
  得到 m  = {2,5,8}
  ```

  - 如$q_0\quad\underrightarrow{m} \quad q_1$也就是从A转移到B：

  ```java
  r =(10*k+m) mod n => 1 = (10*0 + m) mod 3
  得到 m  = {1,4,7}
  ```

  - 如$q_0\quad\underrightarrow{m} \quad q_0$也就是从A转移到A：

  ```java
  r =(10*k+m) mod n => 0 = (10*0 + m) mod 3
  得到 m  = {0,3,6,9}
  ```











### Reference

- [链接](https://www.zhihu.com/question/24824487)





