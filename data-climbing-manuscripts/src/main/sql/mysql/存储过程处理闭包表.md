

```sql
-- 创建存储过程
DROP PROCEDURE
IF
	EXISTS AddNode;

DELIMITER //
CREATE PROCEDURE AddNode ( _parent_name VARCHAR ( 255 ), _node_name VARCHAR ( 255 ) ) BEGIN
DECLARE
		_ancestor INT;
	DECLARE
		_descendant INT;
	DECLARE
		_parent INT;
	IF
		NOT EXISTS ( SELECT node_id FROM nodeinfo WHERE node_name = _node_name ) THEN
			INSERT INTO nodeinfo ( node_name )
		VALUES
			( _node_name );
		
		SET _descendant = ( SELECT node_id FROM nodeinfo WHERE node_name = _node_name );
		INSERT INTO noderelationship ( ancestor, descendant, distance )
		VALUES
			( _descendant, _descendant, 0 );
		IF
			EXISTS ( SELECT node_id FROM nodeinfo WHERE node_name = _parent_name ) THEN
				
				SET _parent = ( SELECT node_id FROM nodeinfo WHERE node_name = _parent_name );
			INSERT INTO noderelationship ( ancestor, descendant, distance ) SELECT
			ancestor,
			_descendant,
			distance + 1 
			FROM
				noderelationship 
			WHERE
				descendant = _parent;
			
		END IF;
		
	END IF;
	
	END;
// 
DELIMITER;
-- 设置格式：非必需
ALTER TABLE nodeinfo CONVERT TO CHARACTER 
SET utf8 COLLATE utf8_unicode_ci;
ALTER TABLE noderelationship CONVERT TO CHARACTER 
SET utf8 COLLATE utf8_unicode_ci;
-- 插入数据
CALL AddNode ( NULL, 'Food' );
CALL AddNode ( 'Food', 'Fruit' );
CALL AddNode ( 'Fruit', 'Red' );
CALL AddNode ( 'Red', 'Cherry' );
CALL AddNode ( 'Fruit', 'Yellow' );
CALL AddNode ( 'Yellow', 'Banana' );
CALL AddNode ( 'Food', 'Meat' );
CALL AddNode ( 'Meat', 'Beef' );
CALL AddNode ( 'Meat', 'Pork' );
```



![image-20210519172617337](D:\Dev\SrcCode\spring-boot-climbing\data-climbing-manuscripts\src\main\sql\mysql\存储过程处理闭包表.assets\image-20210519172617337.png)



![image-20210519172600166](D:\Dev\SrcCode\spring-boot-climbing\data-climbing-manuscripts\src\main\sql\mysql\存储过程处理闭包表.assets\image-20210519172600166.png)

- 查询`Fruit`下所有的子节点

```sql
SELECT
	n3.node_id,
	n3.node_name ,
	n2.distance
FROM
	nodeinfo n1
	INNER JOIN noderelationship n2 ON n1.node_id = n2.ancestor
	INNER JOIN nodeinfo n3 ON n2.descendant = n3.node_id 
WHERE
	n1.node_name = 'Fruit' 
	AND n2.distance != 0
```

- 查询`Fruit`下直属的子节点

```sql
SELECT
	n3.node_id,
	n3.node_name,
	n2.distance 
FROM
	nodeinfo n1
	INNER JOIN noderelationship n2 ON n1.node_id = n2.ancestor
	INNER JOIN nodeinfo n3 ON n2.descendant = n3.node_id 
WHERE
	n1.node_name = 'Fruit' 
	AND n2.distance = 1;
```

- 查询`Fruit`所处的层级

```sql
SELECT
	n2.*,
	n3.node_name 
FROM
	nodeinfo n1
	INNER JOIN noderelationship n2 ON n1.node_id = n2.descendant
	INNER JOIN nodeinfo n3 ON n2.ancestor = n3.node_id 
WHERE
	n1.node_name = 'Fruit' 
ORDER BY
	n2.distance DESC;
```

- 闭包表的优缺点和适用场景
  - 优点：在查询树形结构的任意关系时都很方便。
  - 缺点：需要存储的数据量比较多，索引表需要的空间比较大，增加和删除节点相对麻烦。
  - 适用场合：纵向结构不是很深，增删操作不频繁的场景比较适用。



### Reference

- [MySQL存储过程](https://www.cnblogs.com/mark-chan/p/5384139.html)
- https://blog.csdn.net/shmnh/article/details/81164525